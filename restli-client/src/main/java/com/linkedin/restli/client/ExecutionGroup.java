/*
   Copyright (c) 2021 LinkedIn Corp.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

package com.linkedin.restli.client;

import com.linkedin.parseq.Engine;
import com.linkedin.parseq.ParTask;
import com.linkedin.parseq.Task;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;


/**
 * {@link ExecutionGroup} is used to group requests generated by FluentApis, so the batching support provided
 * by the underlying Rest.Li ParSeq client can be leveraged.
 *
 * The request grouped by execution group will be further grouped by Client so requests will
 * be batched per Client.
 *
 * There are two way to use this
 * (1) Using it with the fluent api and ask the executionGroup to execute explicitly.
 * Example:
 * <blockquote>
 *   <pre>
 *     ExecutionGroup eg;
 *     {@code <YourClient>}.get({@code <Parameter>}, eg); // This request will be passed into ExecutionGroup
 *     eg.execute();
 *   </pre>
 * </blockquote>
 *
 * (2) Use it inside a lambda function. Corresponding FluentAPIs used inside this lambda will be batched.
 * Note in this style, you can still optionally pass the Client type as parameter to specifies requests from which
 * clients the requests need to be batched on. If clients not provided as arguments,
 * all FluentAPI requests will be batched.
 *
 * Example:
 * <blockquote>
 *   <pre>
 *     new ExecutionGroup().batchOn(() -> {
 *       {@code <YourClient>}.get({@code <Parameter1>});
 *       {@code <YourClient>}.get({@code <Parameter2>});
 *     });
 *   </pre>
 * </blockquote>
 * Note: You can use nested executiongroup and each lambda clause have a separate scope.
 * Example:
 * <blockquote>
 *   <pre>
 *     ExecutionGroup otherEg;
 *     new ExecutionGroup().batchOn(() -> {
 *       {@code <YourClient>}.get({@code <Parameter1>}); // implicitly add to the ExecutionGroup which created this lambda
 *       {@code <YourClient>}.get({@code <Parameter2>}); // implicitly add to the ExecutionGroup which created this lambda
 *       new ExecutionGroup().batchOn(() -> {
 *         {@code <YourClient2>}.get({@code <Parameter3>});
 *         {@code <YourClient2>}.get({@code <Parameter4>});
 *       }); // this execution group will not be affecting the outer execution group.
 *       // adding to eg3 explicitly so will not be batched together with other implicit calls in this lambda clause.
 *       {@code <YourClient>}.get({@code <Parameter3>}, eg3);
 *     }); // get call from {@code <YourClient>} with parameter1 and parameter2 will be batched
 *   </pre>
 * </blockquote>
 *
 *
 */
@SuppressWarnings({"rawtypes", "unchecked"})
public class ExecutionGroup
{
  private final Map<FluentClient, List<Task>> _clientToTaskListMap = new HashMap<>();
  private final Engine _engine;

  private Set<FluentClient> _fluentClientAll; // filled by UClient when executionGroup is created; Used for batchOn

  /**
   * This constructor will be called by the UniversalClient and will not be called by API users directly
   * @param engine
   */
  /* package private */ ExecutionGroup(Engine engine)
  {
    _engine = engine;
  }

  /**
   * Execute all the tasks that added to {@link ExecutionGroup} through ParSeq Engine
   */
  public void execute()
  {
    for (Map.Entry<FluentClient, List<Task>> entry : _clientToTaskListMap.entrySet()) {
      List<Task> taskList = entry.getValue();
      // the Task.par(Iterable) version does not fast-fail comparing to Task.par(Task...)
      ParTask<Object> perFluentClientTasks =
          Task.par(taskList.stream().map(obj -> ((Task<Object>) obj)).collect(Collectors.toList()));
      taskList.clear();
      _clientToTaskListMap.remove(entry.getKey());
      // starts a plan for tasks from one client due to performance consideration
      // TODO: optimize, use scheduleAndRun
      _engine.run(perFluentClientTasks);
    }
  }

  /**
   * Run user's logic provided in lambda function and batch related requests made using FluentAPI inside this lambda function
   *
   * Note the FluentAPI requests that take the ExecutionGroup instance as an explicit parameter will not be batched.
   * Also everytime this method is called, it creates a separate ExecutionGroup so nested ExecutionGroup won't be affected.
   *
   * @param runnable the runnable that executes user's logic
   * @param fluentClients the fluentClients whose requests will be batched, if None specified, all fluentClients call
   *                      will be batched.
   * @throws Exception
   */
  public void batchOn(Runnable runnable, FluentClient... fluentClients) throws Exception
  {
    List<FluentClient> batchedClients =
        fluentClients.length > 0 ? new ArrayList<FluentClient>(Arrays.asList(fluentClients))
            : new ArrayList<FluentClient>(_fluentClientAll);

    for (FluentClient fluentClient : batchedClients) {
      fluentClient.setExecutionGroup(this);
    }
    try {
      runnable.run();
      this.execute();
    } finally {
      for (FluentClient fluentClient : batchedClients) {
        fluentClient.removeExecutionGroup();
      }
    }
  }

  public void addTaskByFluentClient(FluentClient client, Task... tasks)
  {
    _clientToTaskListMap.computeIfAbsent(client, (v) -> new ArrayList<>()).addAll(Arrays.asList(tasks));
  }

  /**
   * Add all FluentClients that can be batched on
   *
   * @param fluentClientAll all the FluentClients that can be batched on
   */
  void setFluentClientAll(Set<FluentClient> fluentClientAll)
  {
    _fluentClientAll = fluentClientAll;
  }

  Map<FluentClient, List<Task>> getClientToTaskListMap()
  {
    return _clientToTaskListMap;
  }
}
